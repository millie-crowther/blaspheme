#version 450

#extension GL_ARB_separate_shader_objects : enable

//
// constants
//
const uint is_leaf_flag = 1 << 29;
const uint is_empty_flag = 1 << 30;
const uint unused_flag = 1 << 31;

const uint structure_size = 25000;
const uint max_requests = 64;

struct request_t {
    vec4 aabb;
    
    uvec3 dummy;
    uint i;
};

struct node_t {
    uint header;
    uint b;
    uint c;
    uint d;
};

layout (local_size_x = 16) in;

layout(binding = 1) buffer octree_buffer {
    node_t structure[structure_size];
} octree;

layout(binding = 2) buffer request_buffer {
    request_t requests[max_requests];
} requests;


//
// push constants
//
layout( push_constant ) uniform window_block {
    uvec2 window_size;
    float render_distance;
    uint current_frame;

    vec3 camera_position;
    float dummy2;         

    vec3 camera_right;
    float dummy3;

    vec3 camera_up;
    float dummy4;
} push_const;

bool is_empty_slot(uint i, uint header){
    return ((i - 1) & 7) == 0 && (header & unused_flag) != 0;
}

void main(){
    uint i = gl_GlobalInvocationID.x;

    if (i >= structure_size){
        return;
    }

    // store unused nodes in array for later allocation
    uint header = octree.structure[i].header;
    uint i2 = mix(0, i, is_empty_slot(i, header));
    atomicCompSwap(requests.requests[i % max_requests].i, 0, i2);
    requests.requests[i % max_requests].aabb = vec4(0);

    // cull check

    // TODO: beam opt here
}