#version 450

#extension GL_ARB_separate_shader_objects : enable

//
// constants
//
const uint is_leaf_flag = 1 << 31;
const uint is_empty_flag = 1 << 30;
const uint node_seen_flag = 1 << 29;
const uint structure_size = 25000;

struct octree_node_t {
    uint a;
    uint b;
    uint c;
    uint d;
};

layout (local_size_x = 16) in;

layout(binding = 1) buffer octree_buffer {
    octree_node_t structure[structure_size];
} octree;

//
// push constants
//
layout( push_constant ) uniform window_block {
    uvec2 window_size;
    float render_distance;
    uint current_frame;

    vec3 camera_position;
    float dummy2;         

    vec3 camera_right;
    float dummy3;

    vec3 camera_up;
    float dummy4;
} push_const;

vec3 get_node_centre(uint i){
    // TODO
    return vec3(0);
}

bool should_cull(uint i){
    // cull check occurs on 1/31 of the cells every frame.
    const uint cull_check_mask = 0x1F;
     
    if ((
        (octree.structure[i].a & is_leaf_flag) != 0 ||
        ((i + push_const.current_frame) & cull_check_mask) != 0
    ){
        return false;
    }

    // TODO: check if all children are leaf nodes

    return true;
}

void cull(uint i){
    // TODO
}

bool should_split(uint i){
    return ((a & is_leaf_flag) != 0) && ((a & is_empty_flag) == 0) && ((a & node_seen_flag) != 0);
}

void split(uint i){
    // TODO
}

void main(){
    uint i = gl_GlobalInvocationID.x;

    if (i < structure_size){
        // TODO: create an array of free nodes 

        if (should_cull(i)){
            cull(i);
        } else if (should_split(i)){
            split(i);
        }
    }

    // TODO: beam opt here
}