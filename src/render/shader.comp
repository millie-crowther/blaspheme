#version 450

#extension GL_ARB_separate_shader_objects : enable

//
// constants
//
const uint node_type_unused = 1 << 7;
const uint node_type_empty  = 1 << 6;
const uint node_type_leaf   = 1 << 5;
const uint node_type_branch = 1 << 4;
const uint node_type_stem   = 1 << 3;

const uint structure_size = 25000;
const uint max_requests = 64;

struct request_t {
    vec4 aabb;
    
    uvec2 _;
    uint parent;
    uint child;
};

struct node_t {
    uint header;
    uint b;
    uint c;
    uint d;
};

layout (local_size_x = 16) in;

// extra node at end is to allow shader to avoid branching
// TODO: there will be a very large amount of threads accessing the 
//       single element at the end. investigate if that has a negative 
//       performance impact. number of threads accessing last index is 
//       almost as large as `structure_size`, basically the same.
//       also, this is just a bit hacky. see if theres a better way to do it.
layout(binding = 1) buffer octree_buffer {
    node_t structure[structure_size + 1];
} octree;

layout(binding = 2) buffer request_buffer {
    request_t requests[max_requests];
} requests;

//
// push constants
//
layout( push_constant ) uniform window_block {
    uvec2 window_size;
    float render_distance;
    uint current_frame;

    vec3 camera_position;
    float dummy2;         

    vec3 camera_right;
    float dummy3;

    vec3 camera_up;
    float dummy4;
} push_const;

bool is_empty_slot(uint i, uint header){
    return ((i - 1) & 7) == 0 && (header & unused_flag) != 0;
}

vec3 reverse_lookup(uint i){
    return vec3(0);
}

void main(){
    // uint i = gl_GlobalInvocationID.x;

    // if (i >= structure_size){
    //     return;
    // }

    // uint request = i % max_requests;

    // link up parents of newly requested nodes to their children
    // uint parent = atomicExchange(requests.requests[request].parent, structure_size);
    // octree.structure[parent].c = requests.requests[request].child;
    // octree.structure[parent].header = node_type_stem;
    // uint mask = mix(0, ~0, parent == structure_size);
    // atomicAnd(requests.requests[request].child, mask);

    // store unused nodes in array for later allocation
    // uint header = octree.structure[i].header;
    // uint i2 = mix(0, i, is_empty_slot(i, header));
    // atomicCompSwap(requests.requests[request].child, 0, i2);

    // TODO: cull check

    // TODO: beam opt here
}