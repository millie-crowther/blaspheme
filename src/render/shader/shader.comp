#version 450

layout (local_size_x = 32, local_size_y = 32) in;

layout (binding = 10) uniform writeonly image2D render_texture;

// constants
const uint node_empty_flag = 1 << 24;
const uint node_unused_flag = 1 << 25;
const uint node_child_mask = 0xFFFF;

const uvec2 work_group_count = uvec2(12);
const float sqrt3 = 1.73205080757;
const uint max_depth = 16;

// these ones could be push constants hypothetically
const float f = 1.0;
const int max_steps = 64;
const float epsilon = 1.0 / 256.0;

// types 
struct ray_t {
    vec3 x;
    vec3 d;
};

struct intersection_t {
    bool hit;
    vec3 x;
    vec3 normal;
};

// push constants
layout( push_constant ) uniform push_constants {
    uvec2 window_size;
    float render_distance;
    uint current_frame;

    vec3 camera_position;
    float phi_initial;        

    vec3 camera_right;
    float dummy3;

    vec3 camera_up;
    float dummy4;
} pc;

// input buffers
struct substance_t {
    vec3 c;
    int root;

    float r;
    uint q;
    uint _2;
    uint id;
};

layout (binding = 1) buffer input_buffer { 
    substance_t substances[1024];
    uvec2 octree[]; 
} input_data;

// output buffers
struct request_t {
    vec3 c;
    uint depth;

    uint child;
    uint _1;
    uint substanceID;
    uint _2;
};

layout (binding = 2) buffer request_buffer { request_t requests[]; } requests;

// work group data that is persistent between frames
struct persistent_t {
    vec3 v_min;
    float _1;

    vec3 v_max;
    float _2;
};

layout (binding = 3) buffer persistent_buffer { persistent_t data[]; } persistent;

// shared memory
shared uint vacant_node_index;

shared uint substance_bins[gl_WorkGroupSize.x * gl_WorkGroupSize.y];
shared substance_t substances[32];
shared uvec2 octree[gl_WorkGroupSize.x * gl_WorkGroupSize.y];
shared bool hitmap[gl_WorkGroupSize.x * gl_WorkGroupSize.y / 8];

uint expected_depth(vec3 x){
    vec3 xc = x - pc.camera_position;
    return max(1, 10 - uint(max(0, 7 + 0.5 * log2(dot(xc, xc)))));
}

float expected_size(vec3 x){
    return pc.render_distance / (1 << expected_depth(x)) / 4;
}

uint work_group_offset(){
    return (gl_WorkGroupID.x + gl_WorkGroupID.y * work_group_count.x) * gl_WorkGroupSize.x * gl_WorkGroupSize.y;
}

vec4 colour(vec3 x){
    return vec4(0.8, 0.4, 0.6, 1.0);
}

vec3 normal(uint n){
    return vec3(
        n & 0xFF, (n >> 8) & 0xFF, (n >> 16) & 0xFF
    ) / 127.5 - 1;
}

uint get_bin(vec3 x){
    return 0;
}

vec3 rotate(vec4 q, vec3 x){
    float wx = q.x * q.y;
    float wy = q.x * q.z;
    float wz = q.x * q.w;
    
    float xx = q.y * q.y;
    float xy = q.y * q.z;
    float xz = q.y * q.w;

    float yy = q.z * q.z;
    float yz = q.z * q.w;

    float zz = q.w * q.w;

    return vec3(
        (0.5 - yy - zz) * x.x + (xy - wz) * x.y + (xz + wy) * x.z,
        (xy + wz) * x.x + (0.5 - xx - zz) * x.y + (yz + wx) * x.z,
        (xz - wy) * x.x + (yz - wx) * x.y + (0.5 - xx - yy) * x.z
    ) * 2;

}

float phi_s(ray_t r, substance_t sub, uint expected_depth, out bool hit, out vec3 out_normal){
    // lookup octree node
    vec3 c = vec3(0);
    vec3 s = vec3(sub.r);

    uint i;
    uint depth = 0;
    uint next = sub.root;

    r.x -= sub.c;

    vec4 q = vec4(sub.q & 0xFF, (sub.q >> 8) & 0xFF, (sub.q >> 16) & 0xFF, sub.q >> 24);
    q -= 127.5;
    q /= 127.5;
    r.x = rotate(q, r.x);

    // check against outside bounds of aabb
    vec3 g = abs(r.x) - s;
    float phi_aabb = length(max(g, 0)) + min(max(g.x, max(g.y, g.z)), 0) + epsilon;
    bool outside_aabb = phi_aabb > epsilon;

    for (; depth <= expected_depth && (depth == 0 || next != 0) && (octree[next].x & node_unused_flag) == 0; depth++){
        i = next | uint(dot(step(c, r.x), vec3(1, 2, 4)));
        s /= 2;
        c += sign(r.x - c) * s;
        hitmap[i / 8] = true;
        next = octree[i].x & node_child_mask;
    }

    uvec2 node = octree[i];

    if (depth <= expected_depth && (node.x & node_empty_flag) == 0 && (node.x & node_child_mask) == 0){
        uint request_id = uint(dot(gl_WorkGroupID.xy, vec2(1, work_group_count.x)));

        // TODO: remove this atomic operation. map and reduce?
        uint child_local = atomicAnd(vacant_node_index, 0); 
        if (child_local != 0){
            input_data.octree[i + work_group_offset()].x = child_local;
            requests.requests[request_id] = request_t(
                c, depth, child_local + work_group_offset(), 0, sub.id, 0
            );
        }
    }

    // calculate distance to intersect plane
    vec3 xc = c - r.x;
    vec3 n = normal(node.y);
    out_normal = rotate(vec4(q.x, -q.yzw), n);
    float phi_plane = min(0,
        dot(xc, n) - (float(node.y) / 2139095040 - 1) * length(s)
    ) / dot(r.d, n);

    // calculate distance to edge of bounding cube
    vec3 cube_i = (xc + sign(r.d) * s) / r.d;
    float phi_cube = min(cube_i.x, min(cube_i.y, cube_i.z)) + epsilon;

    // advance ray appropriately
    hit = 
        (node.x & node_empty_flag) == 0 && !outside_aabb &&
        phi_plane >= 0 && phi_plane < phi_cube;
    
    return mix(mix(phi_cube, phi_plane, hit), phi_aabb, outside_aabb);
}

intersection_t raycast(ray_t r){
    bool hit = false;
    vec3 out_normal;

    uint steps = 0;
    for (; !hit && steps < max_steps && length(r.x) < pc.render_distance; steps++){
        uint bin = get_bin(r.x);
        uint num_substances = substance_bins[bin] & 0xFFFFFFFF;
        uint substance_index = substance_bins[bin] >> 16;

        uint expected_depth = expected_depth(r.x);
        float phi = mix(pc.render_distance, expected_size(r.x) + epsilon, num_substances == 0);
        for (uint substanceID = substance_index; !hit && substanceID < substance_index + num_substances; substanceID++){
            substance_t s = substances[substanceID];
            phi = min(phi, phi_s(r, s, expected_depth, hit, out_normal));
        }
        r.x += r.d * phi;
    }

    return intersection_t(hit && steps < max_steps, r.x, out_normal);
}

float shadow(vec3 l, vec3 p){
    return 1;
    // intersection_t i = raycast(ray_t(l, normalize(p - l)));
    // return float(length(i.x - p) < epsilon * 2);
}

vec4 light(vec3 light_p, vec3 x, vec3 n){
    vec4 colour = vec4(50);
    float kd = 0.5;
    float ks = 0.76;
    float shininess = 32;

    // attenuation
    float dist = length(light_p - x);
    float attenuation = 1.0 / (dist * dist);

    //ambient 
    vec4 a = vec4(0.5, 0.5, 0.5, 1.0);

    //shadows
    float shadow = shadow(light_p, x);

    //diffuse
    vec3 l = normalize(light_p - x);

    vec4 d = kd * dot(l, n) * colour;

    //specular
    vec3 v = x - pc.camera_position;
    vec3 right = pc.camera_right;
    vec3 u = pc.camera_up;

    // TODO: not sure about order of cross product here??
    v = vec3(dot(v, right), dot(v, u), dot(v, cross(u, right))); 
    v = normalize(v);

    vec3 r = reflect(l, n);
    vec4 s = ks * pow(max(dot(r, v), epsilon), shininess) * colour;
    return a + (d + s) * attenuation * shadow;
}

vec4 sky(){
    return vec4(0.5, 0.7, 0.9, 1.0);
}

void render(){
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);
    uv = uv * 2.0 - 1.0;
    uv.y *= -1;
    
    vec3 up = pc.camera_up;
    vec3 right = pc.camera_right;
    vec3 x0 = pc.camera_position;

    vec3 forward = cross(right, up);

    // create ray direction vector. remove zero components for efficiency later on
    vec3 d = normalize(forward * f + right * uv.x + up * uv.y);
    d += vec3(equal(d, vec3(0))) * epsilon;
    
    vec4 out_colour = sky();

    ray_t r = ray_t(x0+ pc.phi_initial * d, d);
    intersection_t i = raycast(r);

    if (i.hit){
        out_colour = colour(i.x) * light(vec3(-3, 3, -3), i.x, i.normal);
    }
    imageStore(render_texture, ivec2(gl_GlobalInvocationID.xy), out_colour);
}

void prerender(uint i){
    // clear shared variables
    vacant_node_index = 0;
    hitmap[i / 8] = false;
    substance_bins[i] = 0;

    // load octree from global memory into shared memory
    octree[i] = input_data.octree[i + work_group_offset()];

    // submit free nodes to request queue
    if (i % 8 == 0 && (octree[i].x & node_unused_flag) != 0){
        vacant_node_index = i;
    }

    // load substances into shared memory
    if (i < 32){
        substances[i] = input_data.substances[i];
    }

    substance_bins[0] = 3;
}

void postrender(uint i){
    // cull nodes that havent been seen this frame
    uint c = (octree[i].x & node_child_mask);
    if (!hitmap[c / 8]){
        input_data.octree[i + work_group_offset()].x &= ~node_child_mask;
        input_data.octree[c + work_group_offset()].x |= node_unused_flag;
    }
}

void main(){
    uint i = gl_LocalInvocationID.x + gl_LocalInvocationID.y * gl_WorkGroupSize.x;

    prerender(i);

    barrier();
    render();
    barrier();

    postrender(i);
}
