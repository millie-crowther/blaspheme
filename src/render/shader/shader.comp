#version 450

layout (local_size_x = 32, local_size_y = 32) in;

layout (binding = 10) uniform writeonly image2D render_texture;

//
// constants
//
const uint node_type_pending_data = 1;
const uint node_type_unused = 2;
const uint node_type_empty = 3;
const uint node_type_leaf = 4;
const uint node_type_branch = 5;

const uint structure_size = 25000;
const uint requests_size = 64;
const float sqrt3 = 1.73205080757;

// these ones could be push constants hypothetically
const float f = 1.0;
const int max_steps = 128;
const float epsilon = 1.0 / 256.0;
const float sigma = 64; // TODO: relate this to camera FOV
const float shadow_softness = 64;

//
// types 
//
struct request_t {
    vec4 aabb;
    
    uint child;
    uint _1;
    uint _2;
    uint _3;
};

// TODO: rename these fields, they suck. change to array if you cant think of a name
struct octree_data_t {
    uint header;
    uint b;
    uint c;
    uint d;
};

struct ray_t {
    vec3 x;
    vec3 d;
};

struct node_t {
    vec3 min;
    float size;
    uint i;
    uint parent;
};
node_t invalid_node = node_t(vec3(0), -1.0, 0, 0);

struct intersection_t {
    bool hit;
    vec3 x;
    vec3 n;
    node_t node;
    octree_data_t data;
};
intersection_t null_intersection = intersection_t(
    false, vec3(0), vec3(0), 
    invalid_node, octree_data_t(0, 0, 0, 0)
);

//
// push constants
//
layout( push_constant ) uniform push_constants {
    uvec2 window_size;
    float render_distance;
    uint current_frame;

    vec3 camera_position;
    float dummy2;        

    vec3 camera_right;
    float dummy3;

    vec3 camera_up;
    float dummy4;
} push_const;

//
// buffers
//
layout(binding = 1) buffer octree_buffer {
    octree_data_t structure[structure_size];
} octree;

layout(binding = 2) buffer request_buffer {
    request_t requests[requests_size];
} requests;

void observe(node_t node){
    vec4 aabb = vec4(node.min, node.size / 2);
    bool should_request = aabb.w > epsilon * max(1, sigma * length(aabb.xyz + aabb.w / 2 - push_const.camera_position));

    if (should_request){
        uint ri = node.i % requests_size;
        request_t r = requests.requests[ri];

        if (r.child > 0 && atomicCompSwap(octree.structure[r.child].header, node_type_unused, node_type_pending_data) == node_type_unused){
            for (uint c = 1; c < 8; c++){
                octree.structure[r.child + c].header = node_type_pending_data;
            }

            // observe parent
            uint parent_timestamp = octree.structure[node.parent].header;
            parent_timestamp &= 0xFFFF00FF;
            parent_timestamp |= (push_const.current_frame & 0xFF) << 8;
            octree.structure[node.parent].header = parent_timestamp;

            octree.structure[node.i].c = r.child;
            octree.structure[node.i].header = node_type_branch;
            requests.requests[ri].aabb = aabb;
        }
    }
}

node_t base_node(){
    return node_t(vec3(-push_const.render_distance), push_const.render_distance * 2, 0, 0);
}

node_t octree_lookup(vec3 x){
    vec3 a = abs(x);
    bool invalid = max(a.x, max(a.y, a.z)) > push_const.render_distance;

    if (invalid){ 
        return invalid_node;
    }

    node_t node = base_node();

    while ((octree.structure[node.i].header & 0xFF) == node_type_branch){
        node.parent = node.i;
        node.i = octree.structure[node.i].c;
        node.size /= 2;

        bvec3 octant = greaterThan(x, node.min + node.size);
        node.i += int(octant.x) + (int(octant.y) << 1) + (int(octant.z) << 2);
        node.min += vec3(octant) * node.size;
    }

    if (octree.structure[node.i].header == node_type_pending_data){
        return invalid_node;
    }

    return node;
}

vec3 normal(octree_data_t data){
    return vec3(
        data.b & 0xFF, (data.b >> 8) & 0xFF, (data.b >> 16) & 0xFF
    ) / 127.5 - 1;
}

intersection_t plane_intersection(ray_t r, node_t node, octree_data_t data){
    vec3 n = normal(data);

    float phi = float(data.b >> 24) / 255.0 - 0.5;

    phi *= sqrt3 * node.size;

    vec3 c = node.min + node.size / 2;
    float d = dot(c, n) - phi;

    float xn = dot(r.x, n);

    if (xn < d){
        return intersection_t(true, r.x, n, node, data);
    }

    float dn = dot(r.d, n);
    float lambda = (d - xn) / (dn + float(dn == 0) * epsilon);

    return intersection_t(lambda >= 0, r.x + lambda * r.d, n, node, data);
}

intersection_t raycast(ray_t r){
    node_t node = base_node();

    intersection_t intersection = null_intersection;
    for (int i = 0; i < max_steps; i++){
        // TODO: there's enough info here to start the lookup 
        //       halfway through the tree instead of at the start.
        //       will have to check how much time that actually saves
	    node = octree_lookup(r.x);

        if (node.size < 0 || node.i >= structure_size){
            break;
        }

        octree_data_t data = octree.structure[node.i];
        if ((data.header & 0xFF) != node_type_empty){
            intersection_t i = plane_intersection(r, node, data);
            if (
                i.hit &&
                i.x.x >= node.min.x && i.x.y >= node.min.y && i.x.z >= node.min.z &&
                i.x.x <= node.min.x + node.size && i.x.y <= node.min.y + node.size &&
                i.x.z <= node.min.z + node.size    
            ){
                intersection = i;
                break;
            }
        }
	
        vec3 lambda_i = abs(
            node.min + sign(max(r.d, 0)) * node.size - r.x
        ) / max(abs(r.d), epsilon);

        float lambda = min(lambda_i.x, min(lambda_i.y, lambda_i.z)) + epsilon;
        r.x += r.d * lambda;
    }

    return intersection;
}

float shadow(vec3 l, vec3 p){
    intersection_t i = raycast(ray_t(l, normalize(p - l)));
    return float(length(i.x - p) < epsilon * 2);
}

vec4 colour(octree_data_t data){
    return vec4(
        data.c & 0xFF, (data.c >> 8) & 0xFF, (data.c >> 16) & 0xFF, data.c >> 24
    ) / 255.0;
}

vec4 phong_light(vec3 light_p, vec3 x, octree_data_t data){
    //TODO: 1) blinn-phong lighting
    //      2) more complex lighting
    vec4 colour = vec4(50);
    float kd = 0.5;
    float ks = 0.76;
    float shininess = 32;

    // attenuation
    float dist = length(light_p - x);
    float attenuation = 1.0 / (dist * dist);

    //ambient 
    vec4 a = vec4(0.5, 0.5, 0.5, 1.0);

    //shadows
    float shadow = shadow(light_p, x);

    //diffuse
    vec3 l = normalize(light_p - x);
    vec3 n = normal(data);

    vec4 d = kd * dot(l, n) * colour;

    //specular
    vec3 v = x - push_const.camera_position;
    vec3 right = push_const.camera_right;
    vec3 u = push_const.camera_up;

    // TODO: not sure about order of cross product here??
    v = vec3(dot(v, right), dot(v, u), dot(v, cross(u, right))); 
    v = normalize(v);

    vec3 r = reflect(l, n);
    vec4 s = ks * pow(max(dot(r, v), epsilon), shininess) * colour;
    return a + (d + s) * attenuation * shadow;
}

vec4 light(vec3 p, vec3 x, octree_data_t data){
    vec3 l = normalize(p - x);
    return phong_light(p, x, data);
}

vec4 sky(){
    return vec4(0.5, 0.7, 0.9, 1.0);
}

void render(){
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);
    uv = uv * 2.0 - 1.0;
    uv.y *= -1;
    
    vec3 up = push_const.camera_up;
    vec3 right = push_const.camera_right;
    vec3 x0 = push_const.camera_position;

    vec3 forward = cross(right, up);

    vec3 d = normalize(forward * f + right * uv.x + up * uv.y);
    
    vec4 out_colour = sky();

    ray_t r = ray_t(x0, d);
    intersection_t i = raycast(r);

    if (i.hit){
        out_colour = colour(i.data) * light(vec3(-3, 3, -3), i.x, i.data);
        observe(i.node); 
    }
    imageStore(render_texture, ivec2(gl_GlobalInvocationID.xy), out_colour);

}

bool node_expired(uint i, octree_data_t data){
    if (i >= structure_size){
        return false;
    }

    if ((data.header & 0xFF) != node_type_branch){
        return false;
    }

    for (uint child = 0; child < 8; child++){
        if ((octree.structure[data.c + child].header & 0xFF) != node_type_leaf){
            return false;
        }
    }

    bool expired = ((data.header >> 8) & 0xFF) == (push_const.current_frame & 0xFF); 

    return expired;
}

void cull(uint i){
    
}

void octree_update(){
    uint i = 
        gl_GlobalInvocationID.x +
        gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;
    octree_data_t data = octree.structure[i];

    // submit free nodes to request queue
    bool should_submit = 
        i < structure_size && 
        (i & 7) == 1 && 
        (data.header & 0xFF) == node_type_unused;
    uint ri = (i >> 3) % requests_size;
    atomicCompSwap(requests.requests[ri].child, int(!should_submit) * structure_size, i);

    if (node_expired(i, data)){
        cull(i);
    }
}

void main(){
    octree_update();
    render();
}