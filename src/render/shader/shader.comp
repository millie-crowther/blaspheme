#version 450

layout (local_size_x = 32, local_size_y = 32) in;

layout (binding = 10) uniform writeonly image2D render_texture;

//
// constants
//
const uint node_empty_flag = 1 << 0;
const uint node_unused_flag = 1 << 1;

const uvec2 work_group_count = uvec2(8);
const float sqrt3 = 1.73205080757;
const uint max_depth = 16;

// these ones could be push constants hypothetically
const float f = 1.0;
const int max_steps = 128;
const float epsilon = 1.0 / 256.0;

//
// types 
//
struct request_t {
    vec3 x;
    uint child;

    uint depth;
    uint unused2;
    uint objectID;
    uint unused3;
};

struct octree_data_t {
    uint header;
    uint geometry;
    uint colour;
    uint child;
};

struct octree_node_t {
    octree_data_t children[8];
};
octree_data_t null_node;

struct ray_t {
    vec3 x;
    vec3 d;
};

struct intersection_t {
    bool hit;
    vec3 x;
    octree_data_t data;
    float d;
};
intersection_t null_intersection = intersection_t(
    false, vec3(0),
    null_node, 0
);

//
// push constants
//
layout( push_constant ) uniform push_constants {
    uvec2 window_size;
    float render_distance;
    uint current_frame;

    vec3 camera_position;
    float dummy2;        

    vec3 camera_right;
    float dummy3;

    vec3 camera_up;
    float dummy4;
} push_const;

//
// buffers
//
layout(binding = 1) buffer octree_buffer {
    octree_node_t body[];
} octree;

layout(binding = 2) buffer request_buffer {
    request_t requests[];
} requests;

//
// shared memory
//
shared uint vacant_node_index;

uint expected_depth(vec3 x){
    // TODO: remove magic numbers from here, also check for efficiency
    vec3 xc = x - push_const.camera_position;
    return 16 - uint(max(0, 7 + 0.5 * log2(dot(xc, xc))));
}

uint work_group_offset(){
    return (gl_WorkGroupID.x + gl_WorkGroupID.y * work_group_count.x) * gl_WorkGroupSize.x * gl_WorkGroupSize.y / 8;
}

void observe(vec3 x, uint j, uint depth, vec4 aabb){
    // mark node as seen for expiration culling
    // octree.body[parent_node].header = 
    //     ((push_const.current_frame - 1) << 24) | (octree.body[parent_node].header & 0xFFFFFF);

    // for vacant_node_index
    memoryBarrierShared();

    uint request_id = gl_WorkGroupID.x + gl_WorkGroupID.y * work_group_count.x;
    bool should_request = 
        requests.requests[request_id].child == 0 &&
        depth < expected_depth(x) &&
        (octree.body[j / 8 + work_group_offset()].children[j % 8].header & node_empty_flag) == 0;

    uint child_local = atomicAnd(vacant_node_index, mix(~0, 0, should_request)); 

    if (child_local != 0 && should_request){
        octree.body[j / 8 + work_group_offset()].children[j % 8].child = child_local;

        vec3 octant = vec3(j & 1, (j & 2) >> 1, (j & 4) >> 2); 
        requests.requests[request_id].x = aabb.xyz + octant * aabb.w;
        requests.requests[request_id].depth = depth + 1;
        requests.requests[request_id].child = child_local / 8 + work_group_offset();
    }
}

octree_data_t octree_lookup(vec3 x, out vec4 aabb){
    aabb = vec4(vec3(-push_const.render_distance), push_const.render_distance);

    uint i = uint(x.x > 0) + (uint(x.y > 0) << 1) + (uint(x.z > 0) << 2);
    uint depth = 0;

    while (octree.body[i / 8 + work_group_offset()].children[i % 8].child != 0){
        uint child = octree.body[i / 8 + work_group_offset()].children[i % 8].child;

        if ((octree.body[child / 8 + work_group_offset()].children[0].header & node_unused_flag) != 0){
            break;
        }   

        depth++;

        aabb.xyz += vec3(i & 1, (i & 2) >> 1, (i & 4) >> 2) * aabb.w;
        aabb.w /= 2;

        uvec3 o = uvec3(greaterThan(x, aabb.xyz + aabb.w));
        i = child | o.x | (o.y << 1) | (o.z << 2);
    }

    observe(x, i, depth, aabb);

    return octree.body[i / 8 + work_group_offset()].children[i % 8];
}

vec4 colour(uint x){
    return vec4(
        x & 0xFF, (x >> 8) & 0xFF, (x >> 16) & 0xFF, x >> 24
    ) / 255.0;
}

vec3 normal(uint n){
    return vec3(
        n & 0xFF, (n >> 8) & 0xFF, (n >> 16) & 0xFF
    ) / 127.5 - 1;
}

intersection_t plane_intersection(ray_t r, octree_data_t data, vec4 aabb){
    bvec3 octant = greaterThan(r.x, aabb.xyz + aabb.w);

    if ((data.header & node_empty_flag) != 0){
        return null_intersection;
    }

    vec3 n = normal(data.geometry);

    float phi = float(data.geometry >> 24) / 255.0 - 0.5;
    phi *= sqrt3 * aabb.w;

    vec3 c = aabb.xyz + vec3(octant) * aabb.w + aabb.w / 2;
    float d = dot(c, n) - phi;

    float xn = dot(r.x, n);

    if (xn < d){
        return intersection_t(true, r.x, data, 0);
    }

    float dn = dot(r.d, n);
    float lambda = (d - xn) / (dn + float(dn == 0) * epsilon);

    return intersection_t(lambda >= 0, r.x + lambda * r.d, data, lambda);
}

intersection_t static_raycast(ray_t r){
    vec4 aabb;
    octree_data_t data = octree_lookup(r.x, aabb);

    bvec3 octant = greaterThan(r.x, aabb.xyz + aabb.w);
    vec3 m = aabb.xyz + vec3(octant) * aabb.w;

    intersection_t intersection = plane_intersection(r, data, aabb);
    if (
        intersection.hit &&
        intersection.x.x >= m.x && intersection.x.x <= m.x + aabb.w && 
        intersection.x.y >= m.y && intersection.x.y <= m.y + aabb.w && 
        intersection.x.z >= m.z && intersection.x.z <= m.z + aabb.w    
    ){
        return intersection;
    }

    vec3 lambda_i = abs(
        m + sign(max(r.d, 0)) * aabb.w - r.x
    ) / max(abs(r.d), epsilon);

    float lambda = min(lambda_i.x, min(lambda_i.y, lambda_i.z)) + epsilon;

    intersection.hit = false;
    intersection.d = lambda;

    return intersection;
}

intersection_t raycast(ray_t r){
    for (int i = 0; i < max_steps; i++){
        intersection_t intersection = static_raycast(r);

        r.x += r.d * (intersection.d + epsilon);

        if (intersection.hit){
            intersection.x = r.x;
            return intersection;
        }

        // check if out of bounds
        vec3 a = abs(r.x);
        if (max(a.x, max(a.y, a.z)) > push_const.render_distance) { 
            return null_intersection;
        }
    }

    return null_intersection;
}

float shadow(vec3 l, vec3 p){
    intersection_t i = raycast(ray_t(l, normalize(p - l)));
    return float(length(i.x - p) < epsilon * 2);
}

vec4 light(vec3 light_p, vec3 x, octree_data_t data){
    //TODO: 1) blinn-phong lighting
    //      2) more complex lighting
    vec4 colour = vec4(50);
    float kd = 0.5;
    float ks = 0.76;
    float shininess = 32;

    // attenuation
    float dist = length(light_p - x);
    float attenuation = 1.0 / (dist * dist);

    //ambient 
    vec4 a = vec4(0.5, 0.5, 0.5, 1.0);

    //shadows
    float shadow = shadow(light_p, x);

    //diffuse
    vec3 l = normalize(light_p - x);
    vec3 n = normal(data.geometry);

    vec4 d = kd * dot(l, n) * colour;

    //specular
    vec3 v = x - push_const.camera_position;
    vec3 right = push_const.camera_right;
    vec3 u = push_const.camera_up;

    // TODO: not sure about order of cross product here??
    v = vec3(dot(v, right), dot(v, u), dot(v, cross(u, right))); 
    v = normalize(v);

    vec3 r = reflect(l, n);
    vec4 s = ks * pow(max(dot(r, v), epsilon), shininess) * colour;
    return a + (d + s) * attenuation * shadow;
}

vec4 sky(){
    return vec4(0.5, 0.7, 0.9, 1.0);
}

void render(){
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);
    uv = uv * 2.0 - 1.0;
    uv.y *= -1;
    
    vec3 up = push_const.camera_up;
    vec3 right = push_const.camera_right;
    vec3 x0 = push_const.camera_position;

    vec3 forward = cross(right, up);

    vec3 d = normalize(forward * f + right * uv.x + up * uv.y);
    
    vec4 out_colour = sky();

    ray_t r = ray_t(x0, d);
    intersection_t i = raycast(r);

    if (i.hit){
        out_colour = colour(i.data.colour) * light(vec3(-3, 3, -3), i.x, i.data);
    }
    imageStore(render_texture, ivec2(gl_GlobalInvocationID.xy), out_colour);
}

// bool should_cull_node(octree_node_t node, uint octant){
//     uint depth = node.header & 0xFF;
//     bool size_cull = depth > expected_depth(node.x + push_const.render_distance / (1 << depth));

//     uint child_index = node.children[octant].child + work_group_offset();
//     octree_node_t child_node = octree.body[child_index];
//     bool expiry_cull = (child_node.header >> 24) == (push_const.current_frame & 0xFF);

//     for (uint i = 0; i < 8; i++){
//         if (child_node.children[i].child != 0){
//             return false;
//         }
//     }

//     return 
//         node.children[octant].child != 0 &&
//         (node.header & node_unused_flag) == 0 &&
//         (node.header & node_pending_data_flag) == 0 &&
//         (size_cull || expiry_cull);
// }

void octree_update(){
    if (gl_LocalInvocationID.xy == uvec2(0)){
        vacant_node_index = 0;
    }
    memoryBarrierShared();

    uint local_id = gl_LocalInvocationID.x + gl_LocalInvocationID.y * gl_WorkGroupSize.x;

    // submit free nodes to request queue
    if (local_id % 8 == 0 && (octree.body[local_id / 8 + work_group_offset()].children[0].header & node_unused_flag) != 0){
        vacant_node_index = local_id;
    }

    // cull extraneous nodes
    // for (uint octant = 0; octant < 8; octant++){
    //     octree_node_t node = octree.body[global_id];

    //     if (should_cull_node(node, octant)){
    //         uint child = node.children[octant].child + work_group_offset();
    //         octree.body[global_id].children[octant].child = 0;
    //         octree.body[child].header |= node_unused_flag;
            
    //         // reset expiration culling counter
    //         octree.body[global_id].header = 
    //             ((push_const.current_frame - 1) << 24) | (node.header & 0xFFFFFF);
    //     }
    // }  
}

void main(){
    octree_update();
    render();
}
