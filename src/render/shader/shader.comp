#version 450

layout (local_size_x = 32, local_size_y = 32) in;

layout (binding = 10) uniform writeonly image2D render_texture;

//
// constants
//
const uint node_type_pending_data = 1;
const uint node_type_unused = 2;
const uint node_type_empty = 3;
const uint node_type_leaf = 4;
const uint node_type_branch = 5;

const uint octree_size = 3125;
const uint requests_size = 64;
const float sqrt3 = 1.73205080757;

// these ones could be push constants hypothetically
const float f = 1.0;
const int max_steps = 128;
const float epsilon = 1.0 / 256.0;
const float sigma = 64; // TODO: relate this to camera FOV
const float shadow_softness = 64;

//
// types 
//
struct request_t {
    vec3 x;
    uint child_24_size_8;
};

struct octree_data_t {
    uint header;
    uint b;
    uint c;
    uint child;
};

struct octree_node_t {
    vec3 x;
    uint header;
    octree_data_t children[8];
};
octree_node_t null_node;

struct ray_t {
    vec3 x;
    vec3 d;
};

struct node_t {
    octree_node_t node;
};
node_t invalid_node = node_t(null_node);

struct intersection_t {
    bool hit;
    vec3 x;
    vec3 n;
    node_t node;
    octree_data_t data;
};
intersection_t null_intersection = intersection_t(
    false, vec3(0), vec3(0), 
    invalid_node, octree_data_t(0, 0, 0, 0)
);

//
// push constants
//
layout( push_constant ) uniform push_constants {
    uvec2 window_size;
    float render_distance;
    uint current_frame;

    vec3 camera_position;
    float dummy2;        

    vec3 camera_right;
    float dummy3;

    vec3 camera_up;
    float dummy4;
} push_const;

//
// buffers
//
layout(binding = 1) buffer octree_buffer {
    octree_node_t body[octree_size];
} octree;

layout(binding = 2) buffer request_buffer {
    request_t requests[requests_size];
} requests;

float expected_size(vec3 x){
    return epsilon * max(1, sigma * length(x - push_const.camera_position));
}

bool should_size_cull(float expected_size, float size, octree_data_t data){
    for (uint child = 0; child < 8; child++){
        if ((octree.body[data.child].children[child].header & 0xFF) != node_type_leaf){
            return false;
        }
    }

    return size < expected_size / 2;
}

void cull(uint i, octree_data_t parent){
    // octree.structure[i].header = node_type_leaf | ((push_const.current_frame & 0xFF) << 8);

    // for (uint j = 0; j < 8; j++){
    //     octree.structure[parent.child * 8 + j].header = node_type_unused;
    // }
}

void observe(intersection_t i, uint parent_node, uint octant_index){
    node_t node = i.node;
    float node_size = 2 * push_const.render_distance / (1 << (i.node.node.header & 0xFF));

    bvec3 octant = greaterThan(i.x, i.node.node.x + node_size);
    octree_data_t data = i.node.node.children[octant_index];
    vec3 m = i.node.node.x + vec3(octant) * node_size;

    vec4 aabb = vec4(m, node_size / 2);
    float s = expected_size(i.x);

    if (aabb.w > s){
        uint ri = uint(parent_node * 8 + octant_index) % requests_size; // TODO: this line is dodgy. suboptimal
        uint child = requests.requests[ri].child_24_size_8 & 0xFFFFFF;

        // TODO: check its okay to write to location before writing (i.e. check for a node thats pending data)
        if (
            child != 0 && 
            atomicCompSwap(octree.body[child].children[0].header, node_type_unused, node_type_pending_data) == node_type_unused
        ){
            for (uint c = 1; c < 8; c++){
                octree.body[child].children[c].header = node_type_pending_data;
            }

            // TODO: observe node to trigger expiration culling
            octree.body[parent_node].children[octant_index].child = child;
            octree.body[parent_node].children[octant_index].header = node_type_branch;
            requests.requests[ri].x = aabb.xyz;
            requests.requests[ri].child_24_size_8 = ((octree.body[parent_node].header + 1) << 24) | child;
        }
    }

    // octree_data_t parent = octree.structure[i.node.parent];
    // if (should_size_cull(s, aabb.w * 2, parent)){
    //     cull(i.node.parent, parent);
    // }
}

node_t base_node(){
    return node_t(octree.body[0]);
}

node_t octree_lookup(vec3 x, out uint parent_node, out uint octant_index, out bool is_valid_node){
    vec3 a = abs(x);
    is_valid_node = true;
    
    if (max(a.x, max(a.y, a.z)) > push_const.render_distance) { 
        is_valid_node = false;
        return invalid_node;
    }

    node_t node = base_node();

    parent_node = 0;
    octant_index = uint(x.x > 0) + (uint(x.y > 0) << 1) + (uint(x.z > 0) << 2);

    while ((octree.body[parent_node].children[octant_index].header & 0xFF) == node_type_branch){
        parent_node = octree.body[parent_node].children[octant_index].child;
        node.node = octree.body[parent_node];

        float node_size = 2 * push_const.render_distance / (1 << (node.node.header & 0xFF));
        bvec3 octant = greaterThan(x, node.node.x + node_size);
        octant_index = uint(octant.x) + (uint(octant.y) << 1) + (uint(octant.z) << 2);
    }

    if (octree.body[parent_node].children[octant_index].header == node_type_pending_data){
        is_valid_node = false;
        return invalid_node;
    }

    return node;
}

vec4 colour(uint c){
    return vec4(
        c & 0xFF, (c >> 8) & 0xFF, (c >> 16) & 0xFF, c >> 24
    ) / 255.0;
}

vec3 normal(uint n){
    return vec3(
        n & 0xFF, (n >> 8) & 0xFF, (n >> 16) & 0xFF
    ) / 127.5 - 1;
}

intersection_t plane_intersection(ray_t r, node_t node){
    float node_size = 2 * push_const.render_distance / (1 << (node.node.header & 0xFF));

    bvec3 octant = greaterThan(r.x, node.node.x + node_size);
    uint octant_index = uint(octant.x) + (uint(octant.y) << 1) + (uint(octant.z) << 2);

    octree_data_t data = node.node.children[octant_index];


    vec3 min = node.node.x + vec3(octant) * node_size;
    vec3 n = normal(data.b);

    float phi = float(data.b >> 24) / 255.0 - 0.5;
    phi *= sqrt3 * node_size;

    vec3 c = min + node_size / 2;
    float d = dot(c, n) - phi;

    float xn = dot(r.x, n);

    if (xn < d){
        return intersection_t(true, r.x, n, node, data);
    }

    float dn = dot(r.d, n);
    float lambda = (d - xn) / (dn + float(dn == 0) * epsilon);

    return intersection_t(lambda >= 0, r.x + lambda * r.d, n, node, data);
}

intersection_t raycast(ray_t r){
    node_t node = base_node();

    intersection_t intersection = null_intersection;
    for (int i = 0; i < max_steps; i++){
        // TODO: there's enough info here to start the lookup 
        //       halfway through the tree instead of at the start.
        //       will have to check how much time that actually saves
        uint parent_node;
        uint octant_index;
        bool is_valid_node;
	    node = octree_lookup(r.x, parent_node, octant_index, is_valid_node);
        float node_size = 2 * push_const.render_distance / (1 << (node.node.header & 0xFF));

        if (!is_valid_node || parent_node >= octree_size){
            break;
        }

        bvec3 octant = greaterThan(r.x, node.node.x + node_size);
        octree_data_t data = node.node.children[octant_index];
        vec3 m = node.node.x + vec3(octant) * node_size;

        if ((data.header & 0xFF) != node_type_empty){
            intersection_t i = plane_intersection(r, node);
            if (
                i.hit &&
                i.x.x >= m.x && i.x.y >= m.y && i.x.z >= m.z &&
                i.x.x <= m.x + node_size && i.x.y <= m.y + node_size &&
                i.x.z <= m.z + node_size    
            ){
                intersection = i;
                observe(i, parent_node, octant_index); 
                break;
            }
        }
	
        vec3 lambda_i = abs(
            m + sign(max(r.d, 0)) * node_size - r.x
        ) / max(abs(r.d), epsilon);

        float lambda = min(lambda_i.x, min(lambda_i.y, lambda_i.z)) + epsilon;
        r.x += r.d * lambda;
    }

    return intersection;
}

float shadow(vec3 l, vec3 p){
    intersection_t i = raycast(ray_t(l, normalize(p - l)));
    return float(length(i.x - p) < epsilon * 2);
}

vec4 phong_light(vec3 light_p, vec3 x, octree_data_t data){
    //TODO: 1) blinn-phong lighting
    //      2) more complex lighting
    vec4 colour = vec4(50);
    float kd = 0.5;
    float ks = 0.76;
    float shininess = 32;

    // attenuation
    float dist = length(light_p - x);
    float attenuation = 1.0 / (dist * dist);

    //ambient 
    vec4 a = vec4(0.5, 0.5, 0.5, 1.0);

    //shadows
    float shadow = shadow(light_p, x);

    //diffuse
    vec3 l = normalize(light_p - x);
    vec3 n = normal(data.b);

    vec4 d = kd * dot(l, n) * colour;

    //specular
    vec3 v = x - push_const.camera_position;
    vec3 right = push_const.camera_right;
    vec3 u = push_const.camera_up;

    // TODO: not sure about order of cross product here??
    v = vec3(dot(v, right), dot(v, u), dot(v, cross(u, right))); 
    v = normalize(v);

    vec3 r = reflect(l, n);
    vec4 s = ks * pow(max(dot(r, v), epsilon), shininess) * colour;
    return a + (d + s) * attenuation * shadow;
}

vec4 light(vec3 p, vec3 x, octree_data_t data){
    vec3 l = normalize(p - x);
    return phong_light(p, x, data);
}

vec4 sky(){
    return vec4(0.5, 0.7, 0.9, 1.0);
}

void render(){
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);
    uv = uv * 2.0 - 1.0;
    uv.y *= -1;
    
    vec3 up = push_const.camera_up;
    vec3 right = push_const.camera_right;
    vec3 x0 = push_const.camera_position;

    vec3 forward = cross(right, up);

    vec3 d = normalize(forward * f + right * uv.x + up * uv.y);
    
    vec4 out_colour = sky();

    ray_t r = ray_t(x0, d);
    intersection_t i = raycast(r);

    if (i.hit){
        out_colour = colour(i.data.c) * light(vec3(-3, 3, -3), i.x, i.data);
    }
    imageStore(render_texture, ivec2(gl_GlobalInvocationID.xy), out_colour);
}

// bool node_expired(uint i, octree_data_t data){
//     if (i >= octree_size){
//         return false;
//     }

//     if ((data.header & 0xFF) != node_type_branch){
//         return false;
//     }

//     for (uint child = 0; child < 8; child++){
//         if ((octree.body[data.child].children[child].header & 0xFF) != node_type_leaf){
//             return false;
//         }
//     }

//     bool expired = ((data.header >> 8) & 0xFF) == (push_const.current_frame & 0xFF); 

//     return expired;
// }

void octree_update(){
    uint i = 
        gl_GlobalInvocationID.x +
        gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;

    // submit free nodes to request queue
    bool should_submit = 
        i < octree_size && 
        (octree.body[i].children[0].header & 0xFF) == node_type_unused;
    atomicCompSwap(requests.requests[i % requests_size].child_24_size_8, int(should_submit) * 0xFF000000, 0xFF000000 | i);

    // if (node_expired(i, octree.body[i].children[0])){
    //     cull(i, octree.body[i]);
    // }
}

void main(){
    octree_update();
    render();
}