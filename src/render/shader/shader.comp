#version 450

layout (local_size_x = 32, local_size_y = 32) in;

layout (binding = 10) uniform writeonly image2D render_texture;

// constants
const uint node_empty_flag = 1 << 24;
const uint node_unused_flag = 1 << 25;
const uint node_child_mask = 0xFFFF;

const uvec2 work_group_count = uvec2(8);
const float sqrt3 = 1.73205080757;
const uint max_depth = 16;

// these ones could be push constants hypothetically
const float f = 1.0;
const int max_steps = 64;
const float epsilon = 1.0 / 256.0;

// types 
struct request_t {
    vec4 aabb;

    uint child;
    uint unused2;
    uint objectID;
    uint unused3;
};

struct ray_t {
    vec3 x;
    vec3 d;
};

struct intersection_t {
    bool hit;
    vec3 x;
    uvec2 node;
};

struct object_t {
    vec3 x;
    uint root;
};

// push constants
layout( push_constant ) uniform push_constants {
    uvec2 window_size;
    float render_distance;
    uint current_frame;

    vec3 camera_position;
    float dummy2;        

    vec3 camera_right;
    float dummy3;

    vec3 camera_up;
    float dummy4;
} push_const;

// input buffers
layout (binding = 1) buffer octree_buffer {
    uvec2 body[];
} octree_global;

// output buffers
layout (binding = 2) buffer request_buffer {
    request_t requests[];
} requests;

// gpu local buffers
layout (binding = 3) buffer visibility_buffer {
    vec4 aabb[];
} visibility;

// shared memory
shared uint vacant_node_index;
shared object_t objects[gl_WorkGroupSize.x * gl_WorkGroupSize.y];
shared uvec2 octree[gl_WorkGroupSize.x * gl_WorkGroupSize.y];
shared bool hitmap[gl_WorkGroupSize.x * gl_WorkGroupSize.y / 8];

uint get_object_at(vec3 x){
    if (x.y < 0.0001){
        return 1;
    } else {
        return 0;
    }
}

uint expected_depth(vec3 x){
    vec3 xc = x - push_const.camera_position;
    return max(1, 17 - uint(max(0, 7 + 0.5 * log2(dot(xc, xc)))));
}

uint work_group_offset(){
    return (gl_WorkGroupID.x + gl_WorkGroupID.y * work_group_count.x) * gl_WorkGroupSize.x * gl_WorkGroupSize.y;
}

void request_data(uint i, uint objectID, vec4 aabb){
    uint request_id = gl_WorkGroupID.x + gl_WorkGroupID.y * work_group_count.x;
    uint child_local = atomicAnd(vacant_node_index, 0); 

    if (child_local != 0){
        octree_global.body[i + work_group_offset()].x |= child_local;

        requests.requests[request_id].objectID = objectID;
        requests.requests[request_id].aabb = aabb;
        requests.requests[request_id].child = child_local + work_group_offset();
    }
}

uvec2 octree_lookup(vec3 x, out vec4 aabb){
    uint objectID = get_object_at(x);

    aabb = vec4(vec3(-push_const.render_distance), 2 * push_const.render_distance);
    uint i = objects[objectID].root;
    uvec2 node = uvec2(0);

    uint expected_depth = expected_depth(x);
    
    for (uint depth = 0; depth <= expected_depth; depth++){
        if (depth != 0 && (node.x & node_child_mask) == 0){
            if ((node.x & node_empty_flag) == 0){
                request_data(i, objectID, aabb);
            }
            break;
        }

        // find octant
        uvec3 o = uvec3(greaterThan(x, aabb.xyz + aabb.w / 2));
        i = (node.x & node_child_mask) | o.x | (o.y << 1) | (o.z << 2);

        // check for presence of child data
        if ((octree[i].x & node_unused_flag) != 0){
            break;
        }   
        node = octree[i];

        // refine bounding box
        aabb.w /= 2;
        aabb.xyz += o * aabb.w;

        // mark hitmap
        hitmap[i / 8] = true;
    }

    aabb.xyz += vec3(greaterThan(x, aabb.xyz + aabb.w)) * aabb.w;

    return node;
}

vec4 colour(vec3 x){
    return vec4(0.8, 0.4, 0.6, 1.0);
}

vec3 normal(uint n){
    return vec3(
        n & 0xFF, (n >> 8) & 0xFF, (n >> 16) & 0xFF
    ) / 127.5 - 1;
}

intersection_t advance_ray(inout ray_t r){
    // lookup octree node
    vec4 aabb;
    uvec2 node = octree_lookup(r.x, aabb);

    // calculate distance to edge of bounding cube
    vec3 cube_i = (aabb.xyz + sign(max(r.d, 0)) * aabb.w - r.x) / r.d;
    float cube = min(cube_i.x, min(cube_i.y, cube_i.z));
    
    // TODO: 
    //      early finish if node empty flag detected???
    //      depending on GPU black magic it may or may not improve performance

    // calculate distance to intersect plane
    vec3 n = normal(node.y);
    float phi = (float(node.y >> 24) / 255.0 - 0.5) * sqrt3 * aabb.w;
    float plane = min(dot(aabb.xyz + aabb.w / 2, n) - phi - dot(r.x, n), 0) / dot(r.d, n);

    // advance ray appropriately
    bool hit = (node.x & node_empty_flag) == 0 && plane >= 0 && plane < cube;
    r.x += r.d * (mix(cube, plane, hit) + epsilon);
    
    return intersection_t(hit, r.x, node);
}

intersection_t raycast(ray_t r){
    intersection_t intersection = intersection_t(false, vec3(0), uvec2(0));

    for (int i = 0; !intersection.hit && i < max_steps; i++){
        intersection = advance_ray(r);
    }

    return intersection;
}

float shadow(vec3 l, vec3 p){
    intersection_t i = raycast(ray_t(l, normalize(p - l)));
    return float(length(i.x - p) < epsilon * 2);
}

vec4 light(vec3 light_p, vec3 x, uvec2 node){
    vec4 colour = vec4(50);
    float kd = 0.5;
    float ks = 0.76;
    float shininess = 32;

    // attenuation
    float dist = length(light_p - x);
    float attenuation = 1.0 / (dist * dist);

    //ambient 
    vec4 a = vec4(0.5, 0.5, 0.5, 1.0);

    //shadows
    float shadow = shadow(light_p, x);

    //diffuse
    vec3 l = normalize(light_p - x);
    vec3 n = normal(node.y);

    vec4 d = kd * dot(l, n) * colour;

    //specular
    vec3 v = x - push_const.camera_position;
    vec3 right = push_const.camera_right;
    vec3 u = push_const.camera_up;

    // TODO: not sure about order of cross product here??
    v = vec3(dot(v, right), dot(v, u), dot(v, cross(u, right))); 
    v = normalize(v);

    vec3 r = reflect(l, n);
    vec4 s = ks * pow(max(dot(r, v), epsilon), shininess) * colour;
    return a + (d + s) * attenuation * shadow;
}

vec4 sky(){
    return vec4(0.5, 0.7, 0.9, 1.0);
}

void render(){
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);
    uv = uv * 2.0 - 1.0;
    uv.y *= -1;
    
    vec3 up = push_const.camera_up;
    vec3 right = push_const.camera_right;
    vec3 x0 = push_const.camera_position;

    vec3 forward = cross(right, up);

    // create ray direction vector. remove zero components for efficiency later on
    vec3 d = normalize(forward * f + right * uv.x + up * uv.y);
    d += vec3(equal(d, vec3(0))) * epsilon;
    
    vec4 out_colour = sky();

    ray_t r = ray_t(x0, d);
    intersection_t i = raycast(r);

    if (i.hit){
        out_colour = colour(i.x) * light(vec3(-3, 3, -3), i.x, i.node);
    }
    imageStore(render_texture, ivec2(gl_GlobalInvocationID.xy), out_colour);
}

void load_octree(uint i){
    // clear shared variables
    vacant_node_index = 0;
    hitmap[i / 8] = false;

    // load octree from global memory into shared memory
    uvec2 node = octree_global.body[i + work_group_offset()];
    octree[i] = node;

    // submit free nodes to request queue
    if (i % 8 == 0 && (node.x & node_unused_flag) != 0){
        vacant_node_index = i;
    }
}

void cull(uint i){
    uint c = (octree[i].x & node_child_mask);
    if (!hitmap[c / 8]){
        octree_global.body[i + work_group_offset()].x &= ~node_child_mask;
        octree_global.body[c + work_group_offset()].x |= node_unused_flag;
    }
}

void main(){
    // initialise object array
    // TODO: do this from CPU and load in
    objects[0] = object_t(vec3(0), 0);
    objects[1] = object_t(vec3(0), 1);

    uint i = gl_LocalInvocationID.x + gl_LocalInvocationID.y * gl_WorkGroupSize.x;

    load_octree(i);

    barrier();
    render();
    barrier();

    cull(i);
}
